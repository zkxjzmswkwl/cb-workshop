## Note
It's important to note that the exact terminology I'm using isn't 100% accurate, this isn't an academic paper.

# What is an interpreted language?
An [interpreter](https://en.wikipedia.org/wiki/Interpreter_(computing)) is a program that reads source code and performs computational operations as instructed by said source code. This is to say that an interpreter doesn't compile anything, generally. You run a program (python) that then reads in source code (a python file) and performs actions as instructed.

So, loosely, an "interpreted language" is a language which does not compile to native assembly, but is intrepreted within its own environment. (Java Runtime Environment, Python, Ruby, etc).

However, there are interpreted languages that *do* compile to an intermediary language, or "IL" for short. C# and Java are the two that come to mind.

- C# -> "IL"
- Java -> "Bytecode"

Diagram:
![Java compilation diagram](https://miro.medium.com/v2/resize:fit:1400/1*wMLokxbS9eorV9h7rrc4Gw.png)

In Java's case, when you compile a `.java` file, the default output of `javac` is a `.class` file. That file contains the bytecode generated by `javac`. Running that `.class` file within the JRE will result in that Java program being ran as you'd expect. You're probably used to seeing `.jar` files when it comes to Java programs. `.jar` files are essentially just `zip` files that contain many `.class` files, as well as metadata/auxiliary information about the program.

C# operates similarly, but with a different intermediary language, aptly called "IL".

This approach of compiled/interpreted hybrid is referred to as `JIT` or "[Just in time compilation](https://en.wikipedia.org/wiki/Just-in-time_compilation)". As the name suggests, when you open a C# or Java application, the intermediary language is, in real time, optimized for your machine and interpreted by the given environment (dotnet or JRE).

# What is a compiled language?

A compiled language is a language for which a compiler exists. Now, I know I just said that both C# and Java have a compilation process, and they do. But that compilation process does not result in assembly. [Assembly](https://p.ryswick.net/p/nOB7RK.yasm) is what your CPU takes in to then generate machine code.

C, C++, D, Rust, Go, and many many others, are "compiled" languages. While technically both Java and C# are compiled at one point in time, they are compiled to an intermediary, not to assembly. The choice to implement JIT compilation is one of optimization. Both C# and Java are notably faster than, say, Ruby or Python. That is, in part, thanks to their intermediary languages. IL and Bytecode, respectively.

Languages for which a native compiler exists, that is a compiler capable of generating assembly, are typically (almost always) orders of magnitude more performant than their interpreted or JIT counter-parts. 

- [Benchmark of compiled languages](https://github.com/drujensen/fib?tab=readme-ov-file#natively-compiled-statically-typed).
- [Same benchmark of JIT compiled languages](https://github.com/drujensen/fib?tab=readme-ov-file#natively-compiled-statically-typed)
- [Same benchmark of purely interpreted languages](https://github.com/drujensen/fib?tab=readme-ov-file#natively-compiled-statically-typed)

You'll notice that C, Fortran, and C++ are the fastest performers in this particular benchmark.

> So why is everything not written in these faster languages?

A good question with a simple answer: development time. While there are clearly much more performant options than Python or Java, as we've just seen, that doesn't mean Python or Java are never the right tool for a given job.

Python, for example, is extremely good at automation of tasks. It's fast enough in many cases and much faster to write than say C++ or Rust. The time developers save while developing a piece of software is often considerable enough to cover the expense of additional servers/machines. That is to say that just because C++ is faster than Python, doesn't mean that C++ is more economically viable than Python. That is a question that must be asked and answered on a case-by-case basis.

<hr>

Common use-cases for better known languages:
- C/C++
- - Hedgefunds
- - - One of the rare circumstances in which nanoseconds matter.
- - Game development
- - - For a long time C++ dominated this particular field. It still does, largely. But it's not gone without competitors, especially within the past decade or so. But, much like House, it has **tenure**. You may not like that it's there, you may not want it to be there, but it has decades of libraries tailor-made for game development, and those aren't going anywhere.
- - Operating systems/kernals

<hr>

- Python
- - Web development
- - - With libraries like [Django](https://www.djangoproject.com/), [FastAPI](https://fastapi.tiangolo.com/), and [Flask](https://flask.palletsprojects.com/en/3.0.x/)
- - Machine learning
- - - Tensorflow, pytorch, tinygrad.
- - Utility/automation scripts

<hr>

- Java
- - Web development
- - - Spring, Spring Boot, other boring shit.
- - Android apps (Java or Kotlin, generally)

<hr>

- Go
- - Networking.
- - - Go has a phenomenal standard library, the best I've used. It makes otherwise complicated network tasks extremely easy.
- - Web development
- - - Again, the standard library. Many things that would typically require multiple libraries in other languages can be achieved with nothing but Go's standard library.

<hr>

# Mixing the two
In Circus, a piece of software I developed primarily in Java, it might surprise you to know that a considerable portion of the codebase was, in fact, C/C++. This can be achieved on every platform, but on Windows it was done through the use of dynamically linked libraries, or a `.dll` file, for short.

Here's an example from a `.dll` file that was used by the Circus project at one point in time.

```cpp
// This function asks the winapi to tell us what the window title is
// of whichever window is in focus at the moment.
// If you have overwatch open, the window title would just be "Overwatch".
// If you have Spotify open, the window title would be something like
// "Spotify - Song Name - Artist"
//
// const char* is a pointer to memory which contains the string of the window title.
// It points to the first character of that string.
// JNI is able to reinterpret `const char*` to a Java `String`.
// It does so by following the pointer, then scanning the subsequent bytes until it finds
// a terminator (`\0`), or until it decides the bytes it's reading are no longer pertaining
// to that string.
extern "C" __declspec(dllexport)
const char* getActiveWindowTitle()
{
    HWND fg = GetForegroundWindow();
    if (fg)
    {
        char title[256];
        GetWindowTextA(fg, title, 256);
        return _strdup(title);
    }
    return _strdup("Nope.avi");
}
```

In Java, using something called [JNI](https://en.wikipedia.org/wiki/Java_Native_Interface), we can interface with native code, calling it as we please from our Java code.

The `.dll` is referenced at runtime, but because Java of course cannot parse and comprehend C++, we need to give it a nudge. All Java knows is that we have loaded the contents (exported functions) from this `.dll` file, but Java doesn't necessarily know everything we need to call them. So, we need to tell it what the functions are called, what types they return, and what parameters they expect. We do so like this:

```java
package software.carter.wilt;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.ptr.PointerByReference;

public interface BoofPack extends Library {
    // JNI assumes the file extension of .dll - For this to not crash,
    // "BoofPacked.dll" needs to be in the same directory as this software when ran.
    BoofPack INSTANCE = (BoofPack) Native.load("BoofPacked", BoofPack.class);

    void moveMouseRel(int x, int y);

    boolean asyncKeystate(int key);
    
    // !! referenced function !!
    String getActiveWindowTitle();

    // You can pass integers as dwords.
    void readProcMem(String title, /* DWORD */int start_loc, /* DWORD */int out);

    PointerByReference getHWNDByTitle(String windowTitle);

    String getTitleByHWND(PointerByReference hwnd);

    // See example for this
    int hashXXH32(String to_hash);

    // https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowpos
    void setWindowLoc(PointerByReference hwnd, int x, int y, int cx, int cy);

    // https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowtexta
    void setWindowText(PointerByReference hwnd, String text);

    // https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
    void spawnProcess(String executablePath);

    // https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setfocus
    void setFocusedWindow(PointerByReference hwnd);
}
```

Now, calling out to our C/C++ code is as easy as

```java
BoofPack.INSTANCE.getActiveWindowTitle();
```

In my case, this was done due to Java's less-than-stellar ability to utilize the [Windows API](https://en.wikipedia.org/wiki/Windows_API) out of the box. More often than not, however, this sort of native interfacing is done to gain speed. You can interface with native libraries like this in most non-native languages. I've personally not worked with a language in which this isn't possible.

To boil it down, you can

- Write the time-consuming bits in C/C++/Rust/D/whatever
- Interface with those from a fast-to-write language like Python
- Get the speed benefit of C/C++/Rust/D/whatever, while your codebase is still largely Python.

