## Note
It's important to note that what the exact terminology I'm using isn't 100% accurate, this isn't an academic paper.

# What is an interpreted language?
An [interpreter](https://en.wikipedia.org/wiki/Interpreter_(computing)) is a program that reads source code and performs computational operations as instructed by said source code. This is to say that an interpreter doesn't compile anything, generally. You run a program (python) that then reads in source code (a python file) and performs actions as instructed.

So, loosely, an "interpreted language" is a language which does not compile to native assembly, but is intrepreted within its own environment. (Java Runtime Environment, Python, Ruby, etc).

However, there are interpreted languages that *do* compile to an intermediary language, or "IL" for short. C# and Java are the two that come to mind.

- C# -> "IL"
- Java -> "Bytecode"

Diagram:
![Java compilation diagram](https://miro.medium.com/v2/resize:fit:1400/1*wMLokxbS9eorV9h7rrc4Gw.png)

In Java's case, when you compile a `.java` file, the default output of `javac` is a `.class` file. That file contains the bytecode generated by `javac`. Running that `.class` file within the JRE will result in that Java program being ran as you'd expect. You're probably used to seeing `.jar` files when it comes to Java programs. `.jar` files are essentially just `zip` files that contain many `.class` files, as well as metadata/auxiliary information about the program.

C# operates similarly, but with a different intermediary language, aptly called "IL".

This approach of compiled/interpreted hybrid is referred to as `JIT` or "[Just in time compilation](https://en.wikipedia.org/wiki/Just-in-time_compilation)". As the name suggests, when you open a C# or Java application, the intermediary language is, in real time, optimized for your machine and interpreted by the given environment (dotnet or JRE).

# What is a compiled language?

A compiled language is a language for which a compiler exists. Now, I know I just said that both C# and Java have a compilation process, and they do. But that compilation process does not result in assembly. [Assembly](https://p.ryswick.net/p/nOB7RK.yasm) is what your CPU takes in to then generate machine code.

C, C++, D, Rust, Go, and many many others, are "compiled" languages. While technically both Java and C# are compiled at one point in time, they are compiled to an intermediary, not to assembly. The choice to implement JIT compilation is one of optimization. Both C# and Java are notably faster than, say, Ruby or Python. That is, in part, thanks to their intermediary languages. IL and Bytecode, respectively.

Languages for which a native compiler exists, that is a compiler capable of generating assembly, are typically (almost always) orders of magnitude more performant than their interpreted or JIT counter-parts. 

- [Benchmark of compiled languages](https://github.com/drujensen/fib?tab=readme-ov-file#natively-compiled-statically-typed).
- [Same benchmark of JIT compiled languages](https://github.com/drujensen/fib?tab=readme-ov-file#natively-compiled-statically-typed)
- [Same benchmark of purely interpreted languages](https://github.com/drujensen/fib?tab=readme-ov-file#natively-compiled-statically-typed)

You'll notice that C, Fortran, and C++ are the fastest performers in this particular benchmark.

> So why is everything not written in these faster languages?

A good question with a simple answer: development time. While there are clearly much more performant options than Python or Java, as we've just seen, that doesn't mean Python or Java are never the right tool for a given job.

Python, for example, is extremely good at automation of tasks. It's fast enough in many cases and much faster to write than say C++ or Rust. The time developers save while developing a piece of software is often considerable enough to cover the expense of additional servers/machines. That is to say that just because C++ is faster than Python, doesn't mean that C++ is more economically viable than Python. That is a question that must be asked and answered on a case-by-case basis.

<hr>

Common use-cases for better known languages:
- C/C++
- - Hedgefunds
- - - One of the rare circumstances in which nanoseconds matter.
- - Game development
- - - For a long time C++ dominated this particular field. It still does, largely. But it's not gone without competitors, especially within the past decade or so. But, much like House, it has **tenure**. You may not like that it's there, you may not want it to be there, but it has decades of libraries tailor-made for game development, and those aren't going anywhere.
- - Operating systems/kernals

<hr>

- Python
- - Web development
- - - With libraries like [Django](https://www.djangoproject.com/), [FastAPI](https://fastapi.tiangolo.com/), and [Flask](https://flask.palletsprojects.com/en/3.0.x/)
- - Machine learning
- - - Tensorflow, pytorch, tinygrad.
- - Utility/automation scripts

<hr>

- Java
- - Web development
- - - Spring, Spring Boot, other boring shit.
- - Android apps (Java or Kotlin, generally)
